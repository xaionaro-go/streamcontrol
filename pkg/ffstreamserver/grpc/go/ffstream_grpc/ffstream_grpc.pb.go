// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package ffstream_grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// FFStreamClient is the client API for FFStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FFStreamClient interface {
	SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error)
	AddInput(ctx context.Context, in *AddInputRequest, opts ...grpc.CallOption) (*AddInputReply, error)
	AddOutput(ctx context.Context, in *AddOutputRequest, opts ...grpc.CallOption) (*AddOutputReply, error)
	ConfigureEncoder(ctx context.Context, in *ConfigureEncoderRequest, opts ...grpc.CallOption) (*ConfigureEncoderReply, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	GetEncoderStats(ctx context.Context, in *GetEncoderStatsRequest, opts ...grpc.CallOption) (*GetEncoderStatsReply, error)
	GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error)
	WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error)
	End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error)
}

type fFStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewFFStreamClient(cc grpc.ClientConnInterface) FFStreamClient {
	return &fFStreamClient{cc}
}

func (c *fFStreamClient) SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error) {
	out := new(SetLoggingLevelReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/SetLoggingLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) AddInput(ctx context.Context, in *AddInputRequest, opts ...grpc.CallOption) (*AddInputReply, error) {
	out := new(AddInputReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/AddInput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) AddOutput(ctx context.Context, in *AddOutputRequest, opts ...grpc.CallOption) (*AddOutputReply, error) {
	out := new(AddOutputReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/AddOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) ConfigureEncoder(ctx context.Context, in *ConfigureEncoderRequest, opts ...grpc.CallOption) (*ConfigureEncoderReply, error) {
	out := new(ConfigureEncoderReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/ConfigureEncoder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetEncoderStats(ctx context.Context, in *GetEncoderStatsRequest, opts ...grpc.CallOption) (*GetEncoderStatsReply, error) {
	out := new(GetEncoderStatsReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetEncoderStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error) {
	out := new(GetOutputSRTStatsReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetOutputSRTStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FFStream_serviceDesc.Streams[0], "/ffstream_grpc.FFStream/WaitChan", opts...)
	if err != nil {
		return nil, err
	}
	x := &fFStreamWaitChanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FFStream_WaitChanClient interface {
	Recv() (*WaitReply, error)
	grpc.ClientStream
}

type fFStreamWaitChanClient struct {
	grpc.ClientStream
}

func (x *fFStreamWaitChanClient) Recv() (*WaitReply, error) {
	m := new(WaitReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fFStreamClient) End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error) {
	out := new(EndReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/End", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FFStreamServer is the server API for FFStream service.
// All implementations must embed UnimplementedFFStreamServer
// for forward compatibility
type FFStreamServer interface {
	SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error)
	AddInput(context.Context, *AddInputRequest) (*AddInputReply, error)
	AddOutput(context.Context, *AddOutputRequest) (*AddOutputReply, error)
	ConfigureEncoder(context.Context, *ConfigureEncoderRequest) (*ConfigureEncoderReply, error)
	Start(context.Context, *StartRequest) (*StartReply, error)
	GetEncoderStats(context.Context, *GetEncoderStatsRequest) (*GetEncoderStatsReply, error)
	GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error)
	WaitChan(*WaitRequest, FFStream_WaitChanServer) error
	End(context.Context, *EndRequest) (*EndReply, error)
	mustEmbedUnimplementedFFStreamServer()
}

// UnimplementedFFStreamServer must be embedded to have forward compatible implementations.
type UnimplementedFFStreamServer struct {
}

func (UnimplementedFFStreamServer) SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLoggingLevel not implemented")
}
func (UnimplementedFFStreamServer) AddInput(context.Context, *AddInputRequest) (*AddInputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInput not implemented")
}
func (UnimplementedFFStreamServer) AddOutput(context.Context, *AddOutputRequest) (*AddOutputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOutput not implemented")
}
func (UnimplementedFFStreamServer) ConfigureEncoder(context.Context, *ConfigureEncoderRequest) (*ConfigureEncoderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureEncoder not implemented")
}
func (UnimplementedFFStreamServer) Start(context.Context, *StartRequest) (*StartReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedFFStreamServer) GetEncoderStats(context.Context, *GetEncoderStatsRequest) (*GetEncoderStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEncoderStats not implemented")
}
func (UnimplementedFFStreamServer) GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputSRTStats not implemented")
}
func (UnimplementedFFStreamServer) WaitChan(*WaitRequest, FFStream_WaitChanServer) error {
	return status.Errorf(codes.Unimplemented, "method WaitChan not implemented")
}
func (UnimplementedFFStreamServer) End(context.Context, *EndRequest) (*EndReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method End not implemented")
}
func (UnimplementedFFStreamServer) mustEmbedUnimplementedFFStreamServer() {}

// UnsafeFFStreamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FFStreamServer will
// result in compilation errors.
type UnsafeFFStreamServer interface {
	mustEmbedUnimplementedFFStreamServer()
}

func RegisterFFStreamServer(s *grpc.Server, srv FFStreamServer) {
	s.RegisterService(&_FFStream_serviceDesc, srv)
}

func _FFStream_SetLoggingLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLoggingLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/SetLoggingLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, req.(*SetLoggingLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_AddInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).AddInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/AddInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).AddInput(ctx, req.(*AddInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_AddOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).AddOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/AddOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).AddOutput(ctx, req.(*AddOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_ConfigureEncoder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureEncoderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).ConfigureEncoder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/ConfigureEncoder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).ConfigureEncoder(ctx, req.(*ConfigureEncoderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetEncoderStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEncoderStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetEncoderStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetEncoderStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetEncoderStats(ctx, req.(*GetEncoderStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetOutputSRTStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputSRTStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetOutputSRTStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, req.(*GetOutputSRTStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_WaitChan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WaitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FFStreamServer).WaitChan(m, &fFStreamWaitChanServer{stream})
}

type FFStream_WaitChanServer interface {
	Send(*WaitReply) error
	grpc.ServerStream
}

type fFStreamWaitChanServer struct {
	grpc.ServerStream
}

func (x *fFStreamWaitChanServer) Send(m *WaitReply) error {
	return x.ServerStream.SendMsg(m)
}

func _FFStream_End_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).End(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/End",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).End(ctx, req.(*EndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FFStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ffstream_grpc.FFStream",
	HandlerType: (*FFStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLoggingLevel",
			Handler:    _FFStream_SetLoggingLevel_Handler,
		},
		{
			MethodName: "AddInput",
			Handler:    _FFStream_AddInput_Handler,
		},
		{
			MethodName: "AddOutput",
			Handler:    _FFStream_AddOutput_Handler,
		},
		{
			MethodName: "ConfigureEncoder",
			Handler:    _FFStream_ConfigureEncoder_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _FFStream_Start_Handler,
		},
		{
			MethodName: "GetEncoderStats",
			Handler:    _FFStream_GetEncoderStats_Handler,
		},
		{
			MethodName: "GetOutputSRTStats",
			Handler:    _FFStream_GetOutputSRTStats_Handler,
		},
		{
			MethodName: "End",
			Handler:    _FFStream_End_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WaitChan",
			Handler:       _FFStream_WaitChan_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ffstream.proto",
}
